\section{Phase 3 - SignalR}
After exhaustive discussions on how to solve the two-way communication discussed in \hyperref[phase2]{Phase 2: REST API}, the group agreed that websockets would be a good solution to our problem. Websockets is a protocol that provides a bidirectional communication between clients and server by establishing a single TCP connection in both direction \parencite{rfc_websockets}. Hence, using websockets both client and server can transfer data whenever they see fit. However, \cite{microsoft_websockets} discourage developers from implementing raw websockets for most applications, and recommends using SignalR instead.

ASP.NET SignalR is a library that at the top layer provides real-time communication using websockets while also provides other transport methods such as long polling as fallback \parencite{microsoft_signalr}. Furthermore, SignalR API supports \emph{remote procedure calls} (RPC) using hubs, meaning we can invoke subroutines on the client from the server and vice versa \parencite{microsoft_signalr}.

During this phase we disregarded our old REST API server and InfluxDB completely. First, setting up an echo server using SignalR, while simultaneously implementing the client code. The client code is required to be implemented independent from the Raspberry Pi code because our goal was to create a communication module that could be reused through inheritence for other devices, e.g. traffic lights, should it be required to set up a new hub with other devices.

After successfully implementing all the necessary methods on the client. The vehicle class that represented the Raspberry Pi device was created. Vehicle class inherits the client class which gives it the ability to connect, listen and send data to the server. Furthermore, the client can also subscribe to events that the server can trigger using RPC.

After witnessing a successful connection between the Raspberry Pi vehicle and our SignalR server we started to implement necessary functionality on the server. A simple scenario was first taken into consideration when we first developed new functionalities. The client will inform the server whenever its velocity has been changed. In this case, the server should informs every vehicles behind that vehicle on the same road to adjust their own velocity accordingly. As a result of this functionality, we are required to continuously keep track of the vehicleÂ´s position. Thus, raising a new issue on how the vehicle information should be stored.

InfluxDB could in theory be used to store the vehicle's position however, since the position is constantly changing it would require the server to continuously read and write on Influx. Hence, the group concluded that in theory this will impact latency on server responsiveness. Thus, unanimously we determined that a live-in-memory database using lists would be better. Using simple mathematics the server could recalculate the vehicle's position based on its previous velocity and a stopwatch whenever it retrieves the information of a vehicle instead.

Expanding further on this concept, new functionalities on the SignalR server was developed to handle vehicles approaching an intersection. With a more complex topology it is also required to expand the database to account for the new road network. Hence, road models and intersections models were created to represent these concepts. Furthermore, the vehicle model on the serverside now also composed of a route planner to represent what it means to be approaching an intersection.

With these improvements, SignalR server proves successful in establishing communications with clients. In addition, with the implemented functionalities the server is able to command the clients to adjust their velocity to avoid collision between vehicles approaching an intersection simultaneously. By reducing velocity of some vehicles it also became apparent that traffic flow is improved, in contrast to stopping a vehicle.
