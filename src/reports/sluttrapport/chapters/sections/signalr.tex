\section{Phase 3 - Websocket with SignalR}\label{phase3}
After extensive research on how to solve the two-way communication discussed in \secref{phase2}, the group agreed that WebSockets would be an excellent solution to our problem. Using WebSockets, both client and server can transfer data whenever they see fit. However, \cite{microsoft_websockets} discourages developers from implementing raw WebSockets for most applications and recommends using SignalR instead.

ASP.NET SignalR is a library that at the top layer provides real-time communication using WebSockets while also providing other transport methods such as long-polling as fallback \parencite{microsoft_signalr}. Furthermore, SignalR API supports \emph{remote procedure calls} (RPC) using hubs, meaning we can invoke subroutines on the client from the server and vice versa \parencite{microsoft_signalr}.

As a result of the failure to attain the result we wanted with REST API and InfluxDB, as discussed in \secref{phase2}, we decided to implement SignalR without InfluxDB on our server instead. First, set up an echo server using SignalR while simultaneously implementing the client code. The client code had to be implemented independently of the Raspberry Pi code. Because our goal was to create a communication module that is reusable through inheritance for other devices, e.g., traffic lights, should it be required to set up a new hub with other devices.

After successfully implementing all the necessary methods on the client, the vehicle class representing the Raspberry Pi device became our next priority. By inheriting the client class, the vehicle class also inherits its ability to connect, listen and send data to the server. Furthermore, the client can also subscribe to events that the server can trigger using RPC.

\subsection{Implementation of traffic on a single lane}
After witnessing a successful connection between the Raspberry Pi vehicle and our SignalR server, we started to implement the necessary functionality on the server. We started with the simple scenario described in \secref{sec:traffic_congestion}. The client will inform the server whenever its velocity has changed. Then, the server will relay this change to every other vehicle behind it on the same road and adjust their velocities accordingly. This server functionality also depends on the continuous monitoring of each vehicle's position. Thus, raising a new issue on how the vehicle information should be stored.

InfluxDB could, in theory, be used to store the vehicle's position; however, since the position is constantly changing, it would require the server to read and write on the database continuously. Hence, the group concluded that this would potentially impact latency on the server. Thus, we unanimously determined that a live-in-memory database storing vehicles in lists would be preferable. With simple mathematics, the server could recalculate the vehicle's position based on its previous velocity and a stopwatch whenever it retrieves the information about a vehicle instead.

We then determined to show the product owner from Accenture what we had been working on, thus inviting him and the external supervisor to the next meeting. This short demonstration consisted of running multiple clients with the server to simulate how multiple vehicles would behave with the intervention of our server. The simulation successfully demonstrated that vehicles were able to adjust their velocities in order to prevent the shockwave phenomena described in \secref{sec:traffic_congestion}, and we received positive feedback. However, our supervisors challenged us to extend our concept and make our solution more complex. They believed implementing an intersection where multiple cars meet could show more advanced traffic management. They believed implementing an intersection where multiple cars meet could show more advanced traffic management.

\subsection{Extending the concept to a more complex scenario - traffic on an intersection}
Expanding further on the concept, new functionalities on the SignalR server were developed to handle vehicles approaching an intersection. With a more complex topology, expanding the database to account for the new road network is also required. Consequently, roads and intersections became required additions to our solution. Furthermore, the vehicle model on the serverside is now also composed of a route planner to represent what it means to be approaching an intersection.

With these improvements and new functionalities, the server can command the clients to adjust their velocity to avoid collisions between vehicles approaching an intersection simultaneously. By reducing the velocity of some vehicles, it also became apparent that traffic flow is improved, in contrast to stopping a vehicle.