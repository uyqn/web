\section{Phase 2 - REST API}\label{phase2}
The project aimed to connect Raspberry Pi devices to a system, and thus, the group decided that the best way to establish this connection was to implement a RESTful API on the server. We also considered data security a critical aspect of an upscaled version of such a system. The group discussed how to store the data about the vehicle's positions during this phase, keeping in mind that we wanted our proof-of-concept to be scalable to real life.

\emph{Representational state transfer} (REST) \emph{application programming interface} (API) provides a way for client and server to establish communication through \emph{hypertext transfer protocol} (HTTP). Using a REST API, clients can send requests to a server to perform standard CRUD (create, read, update and delete) operations on a database \parencite{rest_api}.

Due to the time constraint of the program development, quickly choosing an appropriate type of database for our system was desirable, as migrating databases later could be a big timesink. In this case, we chose to incorporate a time series database. InfluxDB is a time-series database created by InfluxData. It provides a SQL-like syntax that is quick and scalable for querying resources. Moreover, the InfluxDB client library, using the InfluxDB v2 API, provides both ease of installation and supports a multitude of languages \parencite{influxdb}.

During this phase, the group implemented a standard REST API server with C\# with the idea that the Raspberry Pi vehicles should exchange information on their velocity, acceleration, and position to the server. The client should first POST itself to the server. The server will then add the vehicle to the InfluxDB to keep track of the vehicle's information. Then, the vehicle should be able to perform a GET request to the server to retrieve its information.

At this stage, the client would be able to send a PATCH request to the server to update its information. In addition, the server will add a new entry to the database whenever it receives this request. The idea was that the client and server would be able to continuously communicate with each other such that the server could determine the behavior of all connected clients.

However, a RESTful API server could not perform all the required tasks the group wanted the server to do. Firstly, the server was only able to communicate with one client at a time, i.e., the client that sends a request. What the group wanted at this stage was that based on a request, the server should also be able to send its request to all the other clients. In order to achieve this, the server had to send an unprompted response to other clients that were not requesting a resource from the server, which was not possible with our current architecture.

A new solution had to be in place to achieve our goal, so we consulted our supervisors for help. They proposed some solutions for us to research. 

\subsection{Long polling}
Polling is the idea that the server pushes resources to the client. There are mainly two types of polling; short- and long polling. 

When short-polling, a client requests a resource from the server, and the server responds with nothing if the resource is not available. The client will then send a new request after a short amount of time, and the cycle repeats until the client receives the resource it has requested.

Long-polling is similar to short-polling, but the server does not send anything back before the resource is available. In other words, the client sends a request to the server, and the server holds this request until it has a response available to the client. In our case, we wanted every client to perform a GET request to the server on a separate thread and instruct the server to hold onto this request until it had further instructions for the requesting client.

However, implementing a method on the server to block the response introduced more complications to the project. With the asynchronous nature of the controllers implemented on the server, it would also mean that the server will consume a lot of the processing power, which also means that the server's performance will have heavily deteriorated.

\subsection{Implement REST API on the client}
Another solution was to implement the client itself as a REST API server on its own. However, each client needed to send the server its host and port information to achieve this. Also, the server has to be implemented as a client to connect to the vehicles.

\subsection{Webhooks}
Webhooks, according to \cite{webhooks}, is a user-defined callback over HTTP. In our case, we would be implementing webhooks to post notifications on clients based on events sent to the server. This implementation was a good contender to solve our issue. However, implementing webhooks includes extensive research into a system the group had never heard of and scarce information on how to create such a system. The group decided that the time constraint of this project did not justify the time it would take to implement such a system.
